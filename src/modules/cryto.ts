/* eslint-disable no-async-promise-executor */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-unused-vars */
import bcrypt = require('bcrypt');
import crypto = require('crypto');
import SysLog from './SysLog';
import SysEnv from './SysEnv';

/**
 * Encrypt a string
 * @param secret - string to be encrypted
 */
export const bcryptHash = async (secret: string): Promise<string> => {
    return new Promise( async (resolve) => {

      let bcryptSalt = 0;

      bcryptSalt = SysEnv.DB_BCRYPT_SALT;

      const salt = bcrypt.genSaltSync(bcryptSalt);

      await bcrypt.hash(secret, salt, (err: Error, hash: string) => {
        // Store hash in your password DB.
        if (err) {
          throw err;
        }
        resolve(hash);
      });
    });
  };

  export const bcryptCompare = async (secret: string, hash: string): Promise<boolean> => {
      return new Promise(async (resolve) => {
         await bcrypt.compare(secret, hash, (err: Error, same: boolean) => {
              resolve(same);
          });
      });
  }
  
  
  export const genNewCrytoKey = () => {
      const key = crypto.randomBytes(32);
    //   SysLog.info("crytoKey: " + key.toString("hex"))
      return key.toString("hex");
  }
  
  export const genNewCrytoIv = () => {
      const key = crypto.randomBytes(16);
    //   SysLog.info("crytoIv: " + key.toString("hex"))
      return key.toString("hex");
  }
  
  /**
   * Converts the array buffer into string
   * @param buf - array buffer
   */
  function ab2str(buf: ArrayBuffer) {
    return String.fromCharCode.apply(null, Array.from(new Uint16Array(buf)));
  }
  
  /**
   * Convert the string into a Uint16 Array Buffer
   * @param str - string
   */
  function str2ab(str: string) {
    const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
    const bufView = new Uint16Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }
    return bufView;
  }
  /**
   * Convert a string into crypto string using JSON.stringify
   * @param secret - string to encrypt
   */
  export const cryptoStr = (secret: string): Promise<string> => {
    return new Promise((resolve) => {
      const cryptoIv = genNewCrytoIv();
      const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(Buffer.from(SysEnv.JWT_SECRET, 'hex')), Buffer.from(cryptoIv, 'hex') );
      let encrypted = cipher.update(secret);
      encrypted = Buffer.concat([encrypted, cipher.final()]);
      const encryptedStr = { iv: cryptoIv, encryptedData: encrypted.toString('hex') };
      resolve(JSON.stringify(encryptedStr));
    });
  };
  
  /**
   * Convert a string generated by crytoStr to a string
   * @param cryptoStr - cryto string created by JSON stringify
   */
  export const decryptoStr = (cryptoStr: string): Promise<Buffer> => {
    return new Promise((resolve) => {
      const encryptedObj = JSON.parse(cryptoStr);
    //   console.log ("encryptedObj : ", encryptedObj)
      const iv = Buffer.from(encryptedObj.iv, 'hex');
      const encryptedText = Buffer.from(encryptedObj.encryptedData, 'hex');
      const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(SysEnv.JWT_SECRET, 'hex'), iv);
      let decrypted = decipher.update(encryptedText);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      resolve(decrypted);
    });
  };

  export const test_crypto = () => {
    genNewCrytoKey();
    genNewCrytoIv();
    bcryptHash("test string").then ((hash) => {
      SysLog.info("bcrypt hash : " + hash);
      bcryptCompare("test test", hash).then ((same: boolean) => {
        SysLog.info("test test is match", same);
      })
      .catch((err) => {
        throw(err);
      });
      bcryptCompare("test string", hash).then ((same: boolean) => {
        SysLog.info("test string is match", same);
      })
      .catch((err) => {
        throw(err);
      });
    })
    .catch((err) => {
      throw(err);
    });
    cryptoStr("test test").then((encrypted: string) => {
      SysLog.info("Crypto Str: " + encrypted);
      decryptoStr(encrypted).then((str) => {
        SysLog.info("Decrypted crypto str: " + str);
      })
      .catch((err) => {
        throw(err);
      });
    })
    .catch((err) => {
      throw(err);
    });
  }